# Technical Specification: v1.4.0 "Enterprise Scale"

| Field | Value |
|-------|-------|
| **Date** | January 2, 2026 |
| **Target Version** | cl-revenue-ops v1.4.0 |
| **Focus** | Liquidity Efficiency, Resource Hardening, Query Optimization |
| **Status** | Approved for Implementation |

---

## 1. Executive Summary

While previous phases focused on pricing logic (Hill Climbing, Scarcity), Phase v1.4.0 focuses on **System Health** and **Capital Efficiency**.

Current production data indicates that as the node scales (more channels, more history), two bottlenecks emerge:
1.  **Capital Inefficiency:** Large channels trap "lazy capital" because rebalancing targets are static (50% of capacity) rather than dynamic (based on flow).
2.  **Resource Exhaustion:** The `listforwards` RPC call eventually becomes too large to parse in Python, leading to potential OOM (Out of Memory) crashes.

This specification defines the architectural changes required to support high-throughput nodes without increasing resource footprint.

---

## 2. Liquidity Management (The "Smart Capital" Suite)

### Feature 15: Orphan Job Cleanup (Startup Hygiene)
**Objective:** Prevent "Phantom Spending" where old background `sling` processes fight with new plugin logic after a restart.

**Logic Flow:**
1.  **Trigger:** Plugin `init()`.
2.  **Action:** `JobManager` queries `sling-job` (list).
3.  **Resolution:** For every job found, execute `sling-deletejob`.
4.  **Logging:** "Startup Hygiene: Terminated {N} orphan sling jobs."

**Safety:** This ensures a "clean slate" state machine on every boot.

### Feature 16: Volume-Weighted Liquidity Targets
**Objective:** Release "Lazy Capital" from large, low-velocity channels to be deployed to high-velocity sinks.

**Algorithm Change (`modules/rebalancer.py`):**
*   **Current:** `target_sats = capacity * 0.5`
*   **New:**
    ```python
    daily_vol = (sats_in + sats_out) / window_days
    volume_target = daily_vol * 3  # Keep 3 days of inventory
    capacity_target = capacity * 0.5
    
    # Target the LOWER of the two, but respect a safety floor
    target_sats = min(capacity_target, volume_target)
    target_sats = max(500_000, target_sats) # Minimum burst buffer
    ```

**Impact:** A 10M sat channel moving 10k/day currently holds 5M sats. New logic will hold ~500k sats, freeing **4.5M sats** for other routes.

### Feature 17: "Futility" Circuit Breaker
**Objective:** Stop wasting gossip bandwidth and HTLC locks on channels that have broken routing paths.

**Logic Flow:**
1.  **Check:** In `find_rebalance_candidates`, query `channel_failures` table.
2.  **Condition:** If `failure_count > 10`.
3.  **Action:**
    *   Check `last_failure_time`.
    *   If `< 48 hours` ago: **SKIP** candidate entirely.
    *   Log: "Futility Circuit Breaker active."

---

## 3. Architecture & Efficiency (The "High Scale" Suite)

### Feature 18: Database Composite Indexing
**Objective:** Change Fee Controller query complexity from $O(N)$ to $O(\log N)$.

**Schema Update (`modules/database.py`):**
```sql
-- Current: Separate indexes on out_channel and timestamp
-- New: Composite index for specific query pattern
CREATE INDEX IF NOT EXISTS idx_forwards_composite ON forwards(out_channel, timestamp);
```

**Impact:** `get_volume_since()` becomes near-instantaneous regardless of history size (millions of rows).

### Feature 19: In-Memory Garbage Collection
**Objective:** Prevent memory leaks in long-running processes as channels open/close.

**Logic Flow:**
1.  **Trigger:** End of `adjust_all_fees` cycle.
2.  **Input:** List of currently active `channel_id`s from `listpeerchannels`.
3.  **Action:**
    *   Iterate keys of `self._hill_climb_states` and `self._scarcity_states`.
    *   If key not in active list: `del` object.
4.  **Repeat:** For Rebalancer `source_failure_counts`.

### Feature 20: Local SQL Flow Analysis (The "Double-Dip" Fix)
**Objective:** Eliminate the heavy `listforwards` RPC call to prevent CPU spikes and OOM.

**Architecture Refactor:**
1.  **Data Source:** Switch `FlowAnalyzer` from RPC to `self.database`.
2.  **Hydration (Startup):**
    *   Query DB: `SELECT MAX(timestamp) FROM forwards`.
    *   RPC: `listforwards(status='settled', since=max_timestamp)`.
    *   Write missing rows to DB.
3.  **Analysis Query:**
    *   Replace Python loop with SQL Aggregation:
    ```sql
    SELECT 
        SUM(in_msat) as total_in, 
        SUM(out_msat) as total_out
    FROM forwards 
    WHERE (in_channel = ? OR out_channel = ?) 
      AND timestamp > ?
    ```

**Impact:** Reduces CPU usage during flow analysis by ~90% and eliminates the largest RAM dependency.

---

## 4. Implementation Checklist

| File | Feature | Task |
|------|---------|------|
| `cl-revenue-ops.py` | 15, 20 | Add `cleanup_orphans()` call in init; Add Data Hydration logic. |
| `modules/rebalancer.py` | 15, 16, 17, 19 | Add JobManager cleanup; Update target logic; Add Futility check; Add GC. |
| `modules/database.py` | 18, 20 | Add Composite Index; Add `get_flow_aggregation` SQL method. |
| `modules/flow_analysis.py` | 20 | Remove `listforwards` RPC loop; connect to `database.get_flow_aggregation`. |
| `modules/fee_controller.py` | 19 | Add `prune_state` method. |

---

## 5. Risk Assessment

| Risk | Mitigation |
|------|------------|
| **Data Gaps:** If plugin is off for days, local DB has holes. | **Hydration:** Startup logic must pull missing history from RPC before main loops start. |
| **Index Locking:** Creating index on large DB locks writers. | **Startup Only:** Schema updates run before threads start. SQLite `WAL` mode handles concurrency. |
| **Logic Regression:** Volume targets might be *too* aggressive. | **Safety Floor:** `max(500k, target)` ensures burst capacity is preserved. |

---

*Specification Author: Lightning Goats Team*
*Audit Status: Pre-Implementation Review*
*Target: v1.4.0*